Aim of project
Our project aimed to develop a version of the board game Monopoly, specifically following rules for a Short Game, that is playable in a Linux system. The game will be run via local multiplayer (2-4 players) and will utilise a graphical user interface (gui) representing the game board which dynamically updates based on the current playerâ€™s actions. 


Contributions and relevant reflections
Brief summary of contributions
I wrote initial logic for the Space class and most of its derived classes (specifically FreeParking, Go, Property, Railroad, Tax, Utility). I also helped to complete the game board in the Game class, adding the remaining spaces with the relevant information. I also contributed to the main base functionality of the player class, including buy functions, getters and setters, and more. Finally, unrelated to coding, I contributed to the README file, reformatting, including instructions to compile and run the program, and writing the rules for our Monopoly game, and also wrote notes during meetings.

Elaboration of contributions
Throughout the project, I mostly focused on the spaces. I came up with the initial logic for most of the spaces, though most of this was changed in later iterations of the project. For example, in the initial Space abstract class, I only had a function to get the name of the space and a pure virtual function that I intended to control behaviour of when a player lands on the space. In future iterations, the land function was left mostly unused due to complications with rendering. Other members of the group also added more functions relating to the information of the space, and additional utility functions. I wrote the initial logic for all derived Space classes except for Jail and GoToJail (i.e. FreeParking, Go, Property, Railroad, Tax, Utility). I also helped to complete the game board in the Game class, and added about 3/4 of the game board's spaces alongside relevant information, such as space name, or cost to buy an ownable space. In hindsight, I feel like we should have planned more in regards to how we wanted a space to be used throughout the main gameplay loop. 

I also contributed to the player class, where I came up with a lot of the initial functionality, most of which was kept through later iterations of the project. For example, I wrote the functions for buying properties, railroads and utilities, functions for clearing the list of owned properties, railroads and utilities, a few basic getters and setters, and functions to add and subtract a player's money. Other members of the group also contributed to this class, specifically in regards to the player's interaction with the game board, however I feel I contributed quite significantly in this class. In general, I am quite happy that most of the base functionality I implemented in this class stayed through to the end of our project. 

Unrelated to coding, I wrote and formatted most of the README file, contributing to instructions on how to compile and run the game, and writing the game rules for the project (since we did not completely follow the rules for a short game of Monopoly). I think writing the rules we ended up going by helped clarify what we succeeded at and what we had to exclude to complete a working prototype. I also took notes whenever we had meetings, regarding plans and what we would like to get done from what we discussed. I like to think this helped us clarify what our goals from then to our next meeting were. This also allowed us to keep a record of what we discussed which I personally found helpful to reference while working on the project. I also documented a few tests relating to the Jail, Go To Jail, and Tax spaces to ensure behaviours for these functions ran as intended. As our project utilised a gui, we opted to document test cases we did for simplicity's sake, however this is something that could be implemented as a future extension to our project.


Learning experience
Through this project, I got much more familiar with using the unordered_set container. Unordered sets were used in the Player class to store the list of properties, the list of railroads and the list of utilities owned by the player. Prior to this project, I pretty much never touched unordered sets, couldn't see the difference between a set and a map and always just opted to use vectors instead. I found that an unordered set suited this purpose as each value in an unordered set is unique (since you cannot own a property twice), and the order each space is bought does not matter (allowing for faster access). I think I need to be more open to using containers that I am not necessarily familiar with instead of almost always using vectors as other containers might be much more suited to what I am trying to do.

This project also allowed me to become more familiar with programming collaboratively as it is something I have rarely done. Generally, I tried to avoid editing in any files that other members of the group may have been using so as to not cause merge conflicts, and where I have edited a class while another member of the group was working on something, I informed the group and generally focused on adding functions instead of modifying existing ones so as to avoid merge complications. In future, it would be better to work in separate branches and creating pull requests.

I also learnt about formatting syntax for README files. I found the syntax was generally quite similar to that of the messaging app Discord which I am a user of. Thus, I didn't exactly find the syntax too complicated to figure out. This would be useful when writing documentation/instructions in future projects. Overall, readable README files are important for open source projects as they usually include information in an easily accessible manner, thus learning the syntax is especially useful for documentation for an end user.


General reflection
Overall, while we managed to create a working game, we were not completely faithful to the original board game rules and we left out a few aspects that we didn't have time for. Examples of these aspects include but are not limited to, players are unable to mortgage spaces the own, bankruptcy is based solely on a player's cash on hand, and the cards (community chest and chance) were not added. In general, I think we needed to plan and be more organised both in regards to time management and also about details of our implementation. As stated before, my initial plan with the land function in Space was not the best way to implement these things, however I feel if I had a better idea of how we were going to be implementing the gameplay loop and rendering, we wouldn't have run into these complications. On a more positive note, I feel our group communicated well in regards to what we would like to achieve after a meeting, and also updating each other on what we have achieved throughout the project. I think from this project, I realised that board games are very complicated to code. Prior to this project, I never realised how many little rules there are for each aspect of Monopoly, each one increasing the complexity of our implementation. 
